// Modified by Giacomo Tartari
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pkt

import (
	"fmt"
	"io"

	"github.com/cycloidio/pkt-line"
)

type ResponseState int

const (
	ResponseBegin ResponseState = iota
	ResponseScanResponse
	ResponseEnd
)

// ResponseChunk is a chunk of a protocol v2 response.
type ResponseChunk struct {
	Response    []byte
	Delimiter   bool
	EndResponse bool
}

// EncodeToPktLine serializes the chunk.
func (c *ResponseChunk) EncodeToPktLine() []byte {
	if len(c.Response) != 0 {
		return pkt.BytesPacket(c.Response).EncodeToPktLine()
	}
	if c.Delimiter {
		return pkt.DelimPacket{}.EncodeToPktLine()
	}
	if c.EndResponse {
		return pkt.FlushPacket{}.EncodeToPktLine()
	}
	panic("impossible chunk")
}

// Response provides an interface for reading a protocol v2 response.
type Response struct {
	scanner *pkt.PacketScanner
	state   ResponseState
	err     error
	curr    *ResponseChunk
}

// NewResponse returns a new ProtocolV2Response to read from rd.
func NewResponse(rd io.Reader) *Response {
	return &Response{scanner: pkt.NewPacketScanner(rd)}
}

// Err returns the first non-EOF error that was encountered by the
// ProtocolV2Response.
func (r *Response) Err() error {
	return r.err
}

// Chunk returns the most recent request chunk generated by a call to Scan.
//
// The underlying array of Response may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (r *Response) Chunk() *ResponseChunk {
	return r.curr
}

// Scan advances the scanner to the next packet. It returns false when the scan
// stops, either by reaching the end of the input or an error. After scan
// returns false, the Err method will return any error that occurred during
// scanning, except that if it was io.EOF, Err will return nil.
func (r *Response) Scan() bool {
	if r.err != nil || r.state == ResponseEnd {
		return false
	}
	if !r.scanner.Scan() {
		r.err = r.scanner.Err()
		if r.err == nil && r.state != ResponseBegin {
			r.err = pkt.SyntaxError("early EOF")
		}
		return false
	}

	switch p := r.scanner.Packet().(type) {
	case pkt.FlushPacket:
		r.state = ResponseBegin
		r.curr = &ResponseChunk{
			EndResponse: true,
		}
		return true
	case pkt.DelimPacket:
		r.state = ResponseScanResponse
		r.curr = &ResponseChunk{
			Delimiter: true,
		}
		return true
	case pkt.BytesPacket:
		r.state = ResponseScanResponse
		r.curr = &ResponseChunk{
			Response: p,
		}
		return true
	default:
		r.err = pkt.SyntaxError(fmt.Sprintf("unexpected packet: %#v", r.scanner.Packet()))
		return false
	}
}
