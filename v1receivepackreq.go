// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gitprotocolio

import (
	"bytes"
	"fmt"
	"io"
	"strings"
)

type protocolV1ReceivePackRequestState int

const (
	protocolV1ReceivePackRequestStateBegin protocolV1ReceivePackRequestState = iota

	protocolV1ReceivePackRequestStateScanCommandAndCapabilities
	protocolV1ReceivePackRequestStateScanCommand

	protocolV1ReceivePackRequestStateScanCert
	protocolV1ReceivePackRequestStateScanCertVersion
	protocolV1ReceivePackRequestStateScanCertPusher
	protocolV1ReceivePackRequestStateScanCertPusheeOrNonce
	protocolV1ReceivePackRequestStateScanCertNonce
	protocolV1ReceivePackRequestStateScanOptionalCertPushOptions
	protocolV1ReceivePackRequestStateScanCertCommand
	protocolV1ReceivePackRequestStateScanCertGPGLine

	protocolV1ReceivePackRequestStateScanOptionalPushOptions
	protocolV1ReceivePackRequestStateScanPushOptions
	protocolV1ReceivePackRequestStateScanPackFile
)

// ProtocolV1ReceivePackRequestChunk is a chunk of a protocol v1
// git-receive-pack request.
type ProtocolV1ReceivePackRequestChunk struct {
	ClientShallow string

	Capabilities  []string
	OldObjectID   string
	NewObjectID   string
	RefName       string
	EndOfCommands bool

	StartOfPushCert      bool
	PushCertHeader       bool
	Pusher               string
	Pushee               string
	Nonce                string
	CertPushOption       string
	EndOfCertPushOptions bool
	GPGSignaturePart     []byte
	EndOfPushCert        bool

	PushOption       string
	EndOfPushOptions bool

	PackStream []byte
}

// EncodeToPktLine serializes the chunk.
func (c *ProtocolV1ReceivePackRequestChunk) EncodeToPktLine() []byte {
	if c.ClientShallow != "" {
		return BytesPacket([]byte(fmt.Sprintf("shallow %s\n", c.ClientShallow))).EncodeToPktLine()
	}
	if c.OldObjectID != "" && c.NewObjectID != "" && c.RefName != "" {
		if len(c.Capabilities) != 0 {
			return BytesPacket([]byte(fmt.Sprintf("%s %s %s\x00%s\n", c.OldObjectID, c.NewObjectID, c.RefName, strings.Join(c.Capabilities, " ")))).EncodeToPktLine()
		}
		return BytesPacket([]byte(fmt.Sprintf("%s %s %s\n", c.OldObjectID, c.NewObjectID, c.RefName))).EncodeToPktLine()
	}
	if c.EndOfCommands {
		return FlushPacket{}.EncodeToPktLine()
	}
	if c.PushOption != "" {
		return BytesPacket([]byte(fmt.Sprintf("%s\n", c.PushOption))).EncodeToPktLine()
	}
	if c.EndOfPushOptions {
		return FlushPacket{}.EncodeToPktLine()
	}
	if c.StartOfPushCert {
		return BytesPacket([]byte(fmt.Sprintf("push-cert\x00%s\n", strings.Join(c.Capabilities, " ")))).EncodeToPktLine()
	}
	if c.PushCertHeader {
		return BytesPacket([]byte("certificate version 0.1\n")).EncodeToPktLine()
	}
	if c.Pusher != "" {
		return BytesPacket([]byte(fmt.Sprintf("pusher %s\n", c.Pusher))).EncodeToPktLine()
	}
	if c.Pushee != "" {
		return BytesPacket([]byte(fmt.Sprintf("pushee %s\n", c.Pushee))).EncodeToPktLine()
	}
	if c.Nonce != "" {
		return BytesPacket([]byte(fmt.Sprintf("nonce %s\n", c.Nonce))).EncodeToPktLine()
	}
	if c.CertPushOption != "" {
		return BytesPacket([]byte(fmt.Sprintf("push-option %s\n", c.CertPushOption))).EncodeToPktLine()
	}
	if c.EndOfCertPushOptions {
		return BytesPacket([]byte("\n")).EncodeToPktLine()
	}
	if len(c.GPGSignaturePart) != 0 {
		return BytesPacket(c.GPGSignaturePart).EncodeToPktLine()
	}
	if c.EndOfPushCert {
		return BytesPacket([]byte("push-cert-end\n")).EncodeToPktLine()
	}
	// TODO
	if len(c.PackStream) != 0 {
		return c.PackStream
	}
	panic("impossible chunk")
}

// ProtocolV1ReceivePackRequest provides an interface for reading a protocol v1
// git-receive-pack request.
type ProtocolV1ReceivePackRequest struct {
	scanner *PacketScanner
	state   protocolV1ReceivePackRequestState
	err     error
	curr    *ProtocolV1ReceivePackRequestChunk
}

// NewProtocolV1ReceivePackRequest returns a new ProtocolV1ReceivePackRequest to
// read from rd.
func NewProtocolV1ReceivePackRequest(rd io.Reader) *ProtocolV1ReceivePackRequest {
	return &ProtocolV1ReceivePackRequest{scanner: NewPacketScanner(rd)}
}

// Err returns the first non-EOF error that was encountered by the
// ProtocolV1ReceivePackRequest.
func (r *ProtocolV1ReceivePackRequest) Err() error {
	return r.err
}

// Chunk returns the most recent chunk generated by a call to Scan.
func (r *ProtocolV1ReceivePackRequest) Chunk() *ProtocolV1ReceivePackRequestChunk {
	return r.curr
}

// Scan advances the scanner to the next packet. It returns false when the scan
// stops, either by reaching the end of the input or an error. After scan
// returns false, the Err method will return any error that occurred during
// scanning, except that if it was io.EOF, Err will return nil.
func (r *ProtocolV1ReceivePackRequest) Scan() bool {
	if r.err != nil {
		return false
	}
	if !r.scanner.Scan() {
		r.err = r.scanner.Err()
		if r.err == nil && r.state != protocolV1ReceivePackRequestStateScanOptionalPushOptions && r.state != protocolV1ReceivePackRequestStateScanPackFile {
			r.err = SyntaxError("early EOF")
		}
		return false
	}
	pkt := r.scanner.Packet()

transition:
	switch r.state {
	case protocolV1ReceivePackRequestStateBegin:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		if bytes.HasPrefix(bp, []byte("shallow ")) {
			r.curr = &ProtocolV1ReceivePackRequestChunk{
				ClientShallow: strings.TrimPrefix(strings.TrimSuffix(string(bp), "\n"), "shallow "),
			}
			return true
		}
		if bytes.HasPrefix(bp, []byte("push-cert\x00")) {
			r.state = protocolV1ReceivePackRequestStateScanCert
			goto transition
		}
		r.state = protocolV1ReceivePackRequestStateScanCommandAndCapabilities
		goto transition
	case protocolV1ReceivePackRequestStateScanCommandAndCapabilities:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		zss := bytes.SplitN(bp, []byte{0}, 2)
		if len(zss) != 2 {
			r.err = SyntaxError("cannot split into two: " + string(bp))
			return false
		}
		caps := []string{}
		if capStr := strings.TrimPrefix(strings.TrimSuffix(string(zss[1]), "\n"), " "); capStr != "" {
			// This is to avoid strings.Split("", " ") => []string{""}.
			caps = strings.Split(capStr, " ")
		}
		ss := strings.SplitN(string(zss[0]), " ", 3)
		if len(ss) != 3 {
			r.err = SyntaxError("cannot split into three: " + string(zss[0]))
			return false
		}
		r.state = protocolV1ReceivePackRequestStateScanCommand
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			Capabilities: caps,
			OldObjectID:  ss[0],
			NewObjectID:  ss[1],
			RefName:      ss[2],
		}
		return true
	case protocolV1ReceivePackRequestStateScanCommand:
		switch p := pkt.(type) {
		case FlushPacket:
			r.state = protocolV1ReceivePackRequestStateScanOptionalPushOptions
			r.curr = &ProtocolV1ReceivePackRequestChunk{
				EndOfCommands: true,
			}
			return true
		case BytesPacket:
			ss := strings.SplitN(strings.TrimSuffix(string(p), "\n"), " ", 3)
			if len(ss) != 3 {
				r.err = SyntaxError("cannot split into three: " + string(p))
				return false
			}
			r.curr = &ProtocolV1ReceivePackRequestChunk{
				OldObjectID: ss[0],
				NewObjectID: ss[1],
				RefName:     ss[2],
			}
			return true
		default:
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", p))
			return false
		}
	case protocolV1ReceivePackRequestStateScanCert:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		zss := bytes.SplitN(bp, []byte{0}, 2)
		if len(zss) != 2 {
			r.err = SyntaxError("cannot split into two: " + string(bp))
			return false
		}
		caps := []string{}
		if capStr := strings.TrimPrefix(strings.TrimSuffix(string(zss[1]), "\n"), " "); capStr != "" {
			// This is to avoid strings.Split("", " ") => []string{""}.
			caps = strings.Split(capStr, " ")
		}
		r.state = protocolV1ReceivePackRequestStateScanCertVersion
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			Capabilities:    caps,
			StartOfPushCert: true,
		}
		return true
	case protocolV1ReceivePackRequestStateScanCertVersion:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		if string(bp) != "certificate version 0.1\n" {
			r.err = SyntaxError(fmt.Sprintf("unexpected certificate version: %#q", string(bp)))
			return false
		}
		r.state = protocolV1ReceivePackRequestStateScanCertPusher
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			PushCertHeader: true,
		}
		return true
	case protocolV1ReceivePackRequestStateScanCertPusher:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		ss := strings.SplitN(strings.TrimSuffix(string(bp), "\n"), " ", 2)
		if len(ss) != 2 {
			r.err = SyntaxError("cannot split into two: " + string(bp))
			return false
		}
		if ss[0] != "pusher" {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", string(bp)))
			return false
		}
		r.state = protocolV1ReceivePackRequestStateScanCertPusheeOrNonce
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			Pusher: ss[1],
		}
		return true
	case protocolV1ReceivePackRequestStateScanCertPusheeOrNonce:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		ss := strings.SplitN(strings.TrimSuffix(string(bp), "\n"), " ", 2)
		if len(ss) != 2 {
			r.err = SyntaxError("cannot split into two: " + string(bp))
			return false
		}
		if ss[0] == "nonce" {
			r.state = protocolV1ReceivePackRequestStateScanCertNonce
			goto transition
		}
		if ss[0] != "pushee" {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", string(bp)))
			return false
		}
		r.state = protocolV1ReceivePackRequestStateScanCertNonce
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			Pushee: ss[1],
		}
		return true
	case protocolV1ReceivePackRequestStateScanCertNonce:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		ss := strings.SplitN(strings.TrimSuffix(string(bp), "\n"), " ", 2)
		if len(ss) != 2 {
			r.err = SyntaxError("cannot split into two: " + string(bp))
			return false
		}
		if ss[0] != "nonce" {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", string(bp)))
			return false
		}
		r.state = protocolV1ReceivePackRequestStateScanOptionalCertPushOptions
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			Nonce: ss[1],
		}
		return true
	case protocolV1ReceivePackRequestStateScanOptionalCertPushOptions:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		if string(bp) == "\n" {
			r.state = protocolV1ReceivePackRequestStateScanCertCommand
			r.curr = &ProtocolV1ReceivePackRequestChunk{
				EndOfCertPushOptions: true,
			}
			return true
		}
		ss := strings.SplitN(strings.TrimSuffix(string(bp), "\n"), " ", 2)
		if len(ss) != 2 {
			r.err = SyntaxError("cannot split into two: " + string(bp))
			return false
		}
		if ss[0] != "push-option" {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", string(bp)))
			return false
		}
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			CertPushOption: ss[1],
		}
		return true
	case protocolV1ReceivePackRequestStateScanCertCommand:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		if string(bp) == "-----BEGIN PGP SIGNATURE-----\n" {
			r.state = protocolV1ReceivePackRequestStateScanCertGPGLine
			goto transition
		}
		ss := strings.SplitN(strings.TrimSuffix(string(bp), "\n"), " ", 3)
		if len(ss) != 3 {
			r.err = SyntaxError("cannot split into three: " + string(bp))
			return false
		}
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			OldObjectID: ss[0],
			NewObjectID: ss[1],
			RefName:     ss[2],
		}
		return true
	case protocolV1ReceivePackRequestStateScanCertGPGLine:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		if string(bp) == "push-cert-end\n" {
			r.state = protocolV1ReceivePackRequestStateScanPushOptions
			r.curr = &ProtocolV1ReceivePackRequestChunk{
				EndOfPushCert: true,
			}
			return true
		}
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			GPGSignaturePart: bp,
		}
		return true
	case protocolV1ReceivePackRequestStateScanOptionalPushOptions:
		if _, ok := pkt.(PackFileIndicatorPacket); ok {
			r.state = protocolV1ReceivePackRequestStateScanPackFile
			goto transition
		}
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		r.state = protocolV1ReceivePackRequestStateScanPushOptions
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			PushOption: strings.TrimSuffix(string(bp), "\n"),
		}
		return true
	case protocolV1ReceivePackRequestStateScanPushOptions:
		switch p := pkt.(type) {
		case FlushPacket:
			r.state = protocolV1ReceivePackRequestStateScanPackFile
			r.curr = &ProtocolV1ReceivePackRequestChunk{
				EndOfPushOptions: true,
			}
			return true
		case BytesPacket:
			r.curr = &ProtocolV1ReceivePackRequestChunk{
				PushOption: strings.TrimSuffix(string(p), "\n"),
			}
			return true
		default:
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", p))
			return false
		}
	case protocolV1ReceivePackRequestStateScanPackFile:
		r.curr = &ProtocolV1ReceivePackRequestChunk{
			PackStream: pkt.EncodeToPktLine(),
		}
		return true
	}
	panic("impossible state")
}
